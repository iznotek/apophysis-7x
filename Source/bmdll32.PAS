unit bmdll32;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date:  16-7-2005                                            }
{    Generated Time: 08:55:19                                              }
{                                                                          }
{**************************************************************************}

interface
uses
{$IFDEF WIN32}
  Windows;
{$ELSE}
  Wintypes, WinProcs;
{$ENDIF}



{+//************************************************************************ }

{-Filename: dlldefs.h }
{-BrainMaster DLL extension library }
{-header file defining data offsets into dll memory space }
{-begun: 11/21/96 }
{-1/12/97: enlarged value blocks, added control blocks }
{-1/20/97: revised Control Flag area to 0x600 from 0x500 }
{-7/11/97: changed frequencies to new 8-band system }
{-7/14/97: added CONTROL_PARMS }
{-7/14/97: added component LOW & HIGH limits }
{-08/22/01 @gtw Add DLL_DATA_SIZE and remove extra defines. }
{-08/28/01 tfc added defines for waveform & filtered }
{-09/09/01 tfc added value blocks for stdev and nextthresh }
{-11/14/01 gtw Updated IAW design review of 13 Nov 01. }
{-1. Added xx_DAMP_FFT_START and remove }
{-extra channel area. }
{-2. Added xx_FFT_SUMM_START for 32 }
{-FFT bins for 60 seconds of summary data. }
{-11/27/01 gtw Updated IAW design review of 27 Nov 01 }
{-1. Added SIZEOF_SUMM_FFT, }
{-RT_FFT_SUMM_CTRL_START }
{-HEG_VALUE }
{-2. Added AUTO_THRESH, }
{-HEG }
{-flags }
{-3. Added <component>_PERCENT_TARGET values. }
{-4. Updated commentary. }
{-Copyright (C) 2001 BrainMaster Technologies, Inc. }
{-copyright (c) 1996,1997,1998,1999,2000 }
{-Thomas F. Collura, Ph.D., P.E. - all rights reserved }

{-To read a value, use e.g. value = DllCFunc(LT_VAL_START+THETA_VAL, 0); }


{-NOTE: TOTAL IS ONLY 16K. DO NOT GO ABOVE 3FFF THIS IS }
{-DUE TO THE 16-BIT LIMITATION. }

{-FIRST 64K OF DLL SPACE IS DIVIDED UP AS FOLLOWS (addresses in hexadecimal): }
{-NOTE THAT ALL ADDRESSES ARE OF 16-bit WORDS }

{-0000-03FF:***********VALUE BLOCKS FOR 8 CHANNELS 1/2 K TOTAL************************ }
{-VALUE BLOCKS CONTAIN VALUES, THRESHOLD, MAX, MIN, ETC. FOR EACH COMPONENT }
{-0X0000 - BEGIN 1K BLOCK ALLOCATED TO CHANNELS 1-8 VALUE BLOCKS }
{-0X0000 - 0x007F: 128 words: Channel 1 value block ( "Left" ) }
{-0X0080 - 0x00FF: 128 words: Channel 2 value block ( "Right") }
{-0X0100 - 0x017F: 128 words: Channel 3 value block }
{-0X0180 - 0x01FF: 128 words: Channel 4 value block }
{-0X0200 - 0X03FF: (512 words for Channels 5,6,7,8) }

{-0400-05FF:********************LIVE FFT BLOCKS******************************* }
{-64 bytes per spectrum x 8 channels = 512 bytes }
{-0400-043F: CHANNEL 1 LIVE FFT BLOCK POSTED 4 PER SECOND }
{-0440-047F: CHANNEL 2 LIVE FFT BLOCK }
{-0480-04FF: Spare. }
{-0500-053F CHANNEL 1 DAMPED FFT BLOCK POSTED 4 PER SECOND }
{-0540-057F CBANNEL 2 DAMPED FFT BLOCK POSTED 4 PER SECOND }

{-0600-09FF:****CONTROL FLAGS, PARAMETERS, AND SESSION AND CALIBRATION INFO***** }
{-0600-06FF: 128 WORDS CONTROL FLAGS FOR REMOTE SETUP }
{-0700-0800: 128 WORDS CONTROL PARAMETERS }
{-0800-09FF: 256 WORDS SESSION & CALIBRATION INFORMATION }


{-DO NOT USE REGIONS DEFINED BELOW }
{-3000-3FFF:****SUMMARY FFT AREA FOR COMPRESSED SPECTRAL ARRAY 4K TOTAL************* }
{-BEGIN SUMMARY FFT BLOCKS FOR 2 CHANNELS, POSTED 1 PER SECOND }
{-(64 bytes/second = 16 seconds per 1K, or 3.75K per minute) }
{-7.5K: Channel 1 FFT block 1 minute }
{-0.5K: TBD; reserved for control information }
{-7.5K: Channel 2 FFT block 1 minute }
{-0.5K: TBD; reserved for control information }

{-1000-2FFF:*************LIVE EEG AREA 8K TOTAL*************************** }
{-TOTAL OF 30K FOR LIVE EEG CHANNELS 2 CHANNELS RAW & FILTERED }
{-BEGIN LIVE EEG CHANNELS 2 seconds = 240 bytes per record }
{-(USE 256 bytes for round numbers) }
{-CHAN 1 RAW 256 samples }
{-CHAN 2 FILTERED 8 x 256 samples }
{-CHAN 1 RAW 256 samples }
{-CHAN 2 FILTERED 8* 256 samples }
{-CONTROL INFO - SIZES, NUMTRACES, ETC - 128 bytes }

{=************************************************************************ }

const
  DLL_DATA_SIZE = $3fff;
  DLL_EEG_BLOCK_SIZE = $100;

{/// VALUE BLOCK ASSIGNMENTS FOR CHANNELS 1 and 2 (LEFT AND RIGHT) }
const
  LT_VAL_START = $0000;
  RT_VAL_START = $0080;
  CHAN_1_VAL_START = $0000;
  CHAN_2_VAL_START = $0080;

const
  LT_LIVE_FFT_START = $0400;
  RT_LIVE_FFT_START = $0440;
  CHAN_1_LIVE_FFT_START = $0400;
  CHAN_2_LIVE_FFT_START = $0440;

const
  LT_DAMP_FFT_START = $0500;
  RT_DAMP_FFT_START = $0540;
  CHAN_1_DAMP_FFT_START = $0500;
  CHAN_2_DAMP_FFT_START = $0540;

const
  CONTROL_FLAGS_START = $0600;
  CONTROL_PARMS_START = $0700;
  SESSION_INFO_START = $0800;

const
  RT_SUMM_FFT_START = $4000;
  LT_SUMM_FFT_START = $6000;
  CHAN_1_SUMM_FFT_START = $4000;
  CHAN_2_SUMM_FFT_START = $6000;

const
  LT_LIVE_EEG_START = $1000;
  LT_LIVE_DELTA_START = $1100;
  LT_LIVE_THETA_START = $1200;
  LT_LIVE_ALPHA_START = $1300;
  LT_LIVE_LOBETA_START = $1400;
  LT_LIVE_BETA_START = $1500;
  LT_LIVE_HIBETA_START = $1600;
  LT_LIVE_GAMMA_START = $1700;
  LT_LIVE_USER_START = $1800;

const
  RT_LIVE_EEG_START = $1900;
  RT_LIVE_DELTA_START = $2000;
  RT_LIVE_THETA_START = $2100;
  RT_LIVE_ALPHA_START = $2200;
  RT_LIVE_LOBETA_START = $2300;
  RT_LIVE_BETA_START = $2400;
  RT_LIVE_HIBETA_START = $2500;
  RT_LIVE_GAMMA_START = $2600;
  RT_LIVE_USER_START = $2700;

const
  LIVE_EEG_CONTROL = $2800;
  LIVE_EEG_POSITION = $2801;
  LIVE_EEG_SIZE = $2802;
  LIVE_EEG_SAMPLESREAD = $2803;
  LIVE_EEG_SAMPLERATE = $2804;
  LIVE_EEG_NUMTERMS = $2805;

{/// The follow area is for the summary FFT }
{/// information used by the CSA display. }
{/// }
const
  SIZEOF_SUMM_FFT = $0020;
  LT_FFT_SUMM_START = $3000;
  CHAN_1_FFT_SUMM_START = $3000;
  LT_FFT_SUMM_CTRL_START = $3780;
  FFT_SUMM_PTR = $3780;
  RT_FFT_SUMM_START = $3800;
  CHAN_2_FFT_SUMM_START = $3800;
  RT_FFT_SUMM_CTRL_START = $3F80;


{/// THE FOLLOWING OFFSETS MAP INTO VALUE SPACE }
{/// THESE ARE VALUES THAT MASTER WRITES }

const
  DELTA_VAL = $0001;
  THETA_VAL = $0002;
  ALPHA_VAL = $0003;
  LOBETA_VAL = $0004;
  BETA_VAL = $0005;
  HIBETA_VAL = $0006;
  GAMMA_VAL = $0007;
  USER_VAL = $0008;
  RESRV_VAL = $0009;

const
  BASE_MODALFREQ = $000A;
  DELTA_MODALFREQ = $000B;
  THETA_MODALFREQ = $000C;
  ALPHA_MODALFREQ = $000D;
  LOBETA_MODALFREQ = $000E;

const
  DELTA_DAMPED_VAL = $000F;

const
  BASE_THRESH = $0010;
  DELTA_THRESH = $0011;
  THETA_THRESH = $0012;
  ALPHA_THRESH = $0013;
  LOBETA_THRESH = $0014;
  BETA_THRESH = $0015;
  HIBETA_THRESH = $0016;
  GAMMA_THRESH = $0017;
  USER_THRESH = $0018;
  RESRV_THRESH = $0019;

const
  DELTA_COHER = $001A;
  THETA_COHER = $001B;
  ALPHA_COHER = $001C;
  LOBETA_COHER = $001D;

const
  THETA_DAMPED_VAL = $001E;
  ALPHA_DAMPED_VAL = $001F;

const
  BASE_NEXTTHRESH = $0020;
  DELTA_NEXTTHRESH = $0021;
  THETA_NEXTTHRESH = $0022;
  ALPHA_NEXTTHRESH = $0023;
  LOBETA_NEXTTHRESH = $0024;
  BETA_NEXTTHRESH = $0025;
  HIBETA_NEXTTHRESH = $0026;
  GAMMA_NEXTTHRESH = $0027;
  USER_NEXTTHRESH = $0028;
  RESRV_NEXTTHRESH = $0029;

const
  BETA_COHER = $002A;
  HIBETA_COHER = $002B;
  GAMMA_COHER = $002C;
  USER_COHER = $002D;

const
  LOBETA_DAMPED_VAL = $002E;
  BETA_DAMPED_VAL = $002F;

const
  BASE_STDEV = $0030;
  DELTA_STDEV = $0031;
  THETA_STDEV = $0032;
  ALPHA_STDEV = $0033;
  LOBETA_STDEV = $0034;
  BETA_STDEV = $0035;
  HIBETA_STDEV = $0036;
  GAMMA_STDEV = $0037;
  USER_STDEV = $0038;
  RESRV_STDEV = $0039;

const
  DELTA_PHASE = $003A;
  THETA_PHASE = $003B;
  ALPHA_PHASE = $003C;
  LOBETA_PHASE = $003D;

const
  HIBETA_DAMPED_VAL = $003E;
  GAMMA_DAMPED_VAL = $003F;

const
  BASE_MODE = $0040;
  DELTA_MODE = $0041;
  THETA_MODE = $0042;
  ALPHA_MODE = $0043;
  LOBETA_MODE = $0044;
  BETA_MODE = $0045;
  HIBETA_MODE = $0046;
  GAMMA_MODE = $0047;
  USER_MODE = $0048;
  RESRV_MODE = $0049;

const
  BETA_PHASE = $004A;
  HIBETA_PHASE = $004B;
  GAMMA_PHASE = $004C;
  USER_PHASE = $004D;

const
  USER_DAMPED_VAL = $004E;
  DLL_OFFSET_4F = $004F;

const
  BASE_HITS = $0050;
  DELTA_HITS = $0051;
  THETA_HITS = $0052;
  ALPHA_HITS = $0053;
  LOBETA_HITS = $0054;
  BETA_HITS = $0055;
  HIBETA_HITS = $0056;
  GAMMA_HITS = $0057;
  USER_HITS = $0058;
  RESRV_HITS = $0059;

const
  BETA_MODALFREQ = $005A;
  HIBETA_MODALFREQ = $005B;
  GAMMA_MODALFREQ = $005C;
  USER_MODALFREQ = $005D;
  RESRV_MODALFREQ = $005E;

const
  DLL_OFFSET_5F = $005F;

const
  BASE_MEAN = $0060;
  DELTA_MEAN = $0061;
  THETA_MEAN = $0062;
  ALPHA_MEAN = $0063;
  LOBETA_MEAN = $0064;
  BETA_MEAN = $0065;
  HIBETA_MEAN = $0066;
  GAMMA_MEAN = $0067;
  USER_MEAN = $0068;
  RESRV_MEAN = $0069;

const
  BASE_PEAKFREQ = $006A;
  DELTA_PEAKFREQ = $006B;
  THETA_PEAKFREQ = $006C;
  ALPHA_PEAKFREQ = $006D;
  LOBETA_PEAKFREQ = $006E;

const
  DLL_OFFSET_6F = $006F;

const
  BASE_PERCENTTIMEOVERTHRESH = $0070;
  DELTA_PERCENTTIMEOVERTHRESH = $0071;
  THETA_PERCENTTIMEOVERTHRESH = $0072;
  ALPHA_PERCENTTIMEOVERTHRESH = $0073;
  LOBETA_PERCENTTIMEOVERTHRESH = $0074;
  BETA_PERCENTTIMEOVERTHRESH = $0075;
  HIBETA_PERCENTTIMEOVERTHRESH = $0076;
  GAMMA_PERCENTTIMEOVERTHRESH = $0077;
  USER_PERCENTTIMEOVERTHRESH = $0078;
  RESRV_PERCENTTIMEOVERTHRESH = $0079;

const
  BETA_PEAKFREQ = $007A;
  HIBETA_PEAKFREQ = $007B;
  GAMMA_PEAKFREQ = $007C;
  USER_PEAKFREQ = $007D;
  RESRV_PEAKFREQ = $007E;
  HEG_VALUE = $007F;



{/// THE FOLLOWING OFFSETS MAP INTO FLAG SPACE }
{/// THESE ARE SWITCHES THAT MASTER READS }
{/// WE CAN HAVE UP TO 128 SUCH FLAGS }
{/// The gaps between values are not important, }
{/// but care should be used in changing the values. }

const
  DLL_BUSY = $0000;
  WRITE_COUNT = $0001;
  READ_COUNT = $0002;
  DELTA = $0011;
  THETA = $0012;
  ALPHA = $0013;
  LOBETA = $0014;
  BETA = $0015;
  HIBETA = $0016;
  GAMMA = $0017;
  USER = $0018;
  RESRV = $0019;
  SOUND = $0020;
  SAVETODISK = $0021;
  WAVEFORM = $0031;
  PHASE = $0032;
  FFT = $0033;
  MIRROR = $0034;
  THERM = $0035;
  ONEDTREND = $0036;
  TWODTREND = $0037;
  THREEDTREND = $0038;
  CSA = $0039;
  STERMAN = $0040;
  OTHMER = $0041;
  PACMAN = $0042;
  SMILEY = $0043;
  SIMILARITY = $0044;
  PHASE_SIMILRTY = $0045;
  MIDI_VOICE = $0046;
  MIDI_MODE = $0047;
  MIDI_MODULATION = $0048;
  COHERENCE_THRESHOLD = $0049;
  AUTO_THRESH = $004A;
  HEG = $004B;
  EQUALIZER = $004C;
  MASTER_WRITE_COUNT = $004D;
  MASTER_RUNNING = $004E;
  MASTER_PAUSE_FLAG = $004F;
  MASTER_ARTIFACT_FLAG = $0050;
  MASTER_INHIBIT_FLAG = $0051;

const
  MASTER_INHIBIT1_FLAG = $0052;
  MASTER_ENHANCE1_FLAG = $0053;
  MASTER_NUM1_ENHANCES = $0054;
  MASTER_INHIBIT2_FLAG = $0055;
  MASTER_ENHANCE2_FLAG = $0056;
  MASTER_NUM2_ENHANCES = $0057;

{/// THE FOLLOWING OFFSETS MAP INTO CONTROL PARAMETER SPACE }
{/// THESE ARE VALUES THAT MASTER USES }
{/// WE CAN HAVE 128 SUCH PARAMETERS }

const
  DELTA_LOW = $0000;
  DELTA_HIGH = $0001;
  THETA_LOW = $0002;
  THETA_HIGH = $0003;
  ALPHA_LOW = $0004;
  ALPHA_HIGH = $0005;
  LOBETA_LOW = $0006;
  LOBETA_HIGH = $0007;
  BETA_LOW = $0008;
  BETA_HIGH = $0009;
  HIBETA_LOW = $0010;
  HIBETA_HIGH = $0011;
  GAMMA_LOW = $0012;
  GAMMA_HIGH = $0013;
  USER_LOW = $0014;
  USER_HIGH = $0015;
  RESRV_LOW = $0016;
  RESRV_HIGH = $0017;
  FILTER_ORDER = $0018;
  NCHANS = $0019;

const
  CHAN1_DELTA_PERCENT_TARGET = $0020;
  CHAN1_THETA_PERCENT_TARGET = $0021;
  CHAN1_ALPHA_PERCENT_TARGET = $0022;
  CHAN1_LOBETA_PERCENT_TARGET = $0023;
  CHAN1_BETA_PERCENT_TARGET = $0024;
  CHAN1_HIBETA_PERCENT_TARGET = $0025;
  CHAN1_GAMMA_PERCENT_TARGET = $0026;
  CHAN1_USER_PERCENT_TARGET = $0027;

const
  CHAN2_DELTA_PERCENT_TARGET = $0028;
  CHAN2_THETA_PERCENT_TARGET = $0029;
  CHAN2_ALPHA_PERCENT_TARGET = $002A;
  CHAN2_LOBETA_PERCENT_TARGET = $002B;
  CHAN2_BETA_PERCENT_TARGET = $002C;
  CHAN2_HIBETA_PERCENT_TARGET = $002D;
  CHAN2_GAMMA_PERCENT_TARGET = $002E;
  CHAN2_USER_PERCENT_TARGET = $002F;

var
  DLLLoaded: Boolean { is DLL (dynamically) loaded already? }
    {$IFDEF WIN32} = False; {$ENDIF}

var
  Open: function(s: Pchar): Word; stdcall;
var
  DllCFunc: function(x:integer; y:integer): Word; stdcall;


implementation

var
  SaveExit: pointer;
  DLLHandle: THandle;
{$IFNDEF MSDOS}
  ErrorMode: Integer;
{$ENDIF}

  procedure NewExit; far;
  begin
    ExitProc := SaveExit;
    FreeLibrary(DLLHandle)
  end {NewExit};

procedure LoadDLL;
begin
  if DLLLoaded then Exit;
{$IFNDEF MSDOS}
  ErrorMode := SetErrorMode($8000{SEM_NoOpenFileErrorBox});
{$ENDIF}
//  DLLHandle := LoadLibrary('bmdll32.DLL');
//  if DLLHandle < 32 then
    DLLHandle := LoadLibrary('C:\brainm.20a\bmdll32.DLL');

  if DLLHandle >= 32 then begin
    DLLLoaded := True;
    SaveExit := ExitProc;
    ExitProc := @NewExit;
    @Open := GetProcAddress(DLLHandle,'Open');
    Assert(@Open <> nil);
    @DllCFunc := GetProcAddress(DLLHandle,'DllCFunc');
    Assert(@DllCFunc <> nil);

  end else begin
    DLLLoaded := False;
    { Error: DLLDEFS.DLL could not be loaded !! }
  end;
{$IFNDEF MSDOS}
  SetErrorMode(ErrorMode)
{$ENDIF}
end {LoadDLL};

begin
  LoadDLL;
end.
